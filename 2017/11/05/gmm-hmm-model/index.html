<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="GMM-HMM模型（理论篇）"/>




  <meta name="keywords" content="语音识别,机器学习," />





  <link rel="alternate" href="/default" title="harryfyodor">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/"/>


<meta name="description" content="语音识别有一条最基础的公式： W^{*} = \mathop{argmax}_{W} P(W|X)P(W|X)=\frac{p(X|W)P(W)}{p(X)}\propto p(X|W)P(W)W^{*} = \mathop{argmax}_{W} p(X|W)P(W)这条公式使用了贝叶斯公式，把语音识别分成了两个部分。一部分是声学模型，一部分是语言模型。直观地理解，就是估计一个词，使得公式右侧的">
<meta name="keywords" content="语音识别,机器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="GMM-HMM模型（理论篇）">
<meta property="og:url" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/index.html">
<meta property="og:site_name" content="harryfyodor">
<meta property="og:description" content="语音识别有一条最基础的公式： W^{*} = \mathop{argmax}_{W} P(W|X)P(W|X)=\frac{p(X|W)P(W)}{p(X)}\propto p(X|W)P(W)W^{*} = \mathop{argmax}_{W} p(X|W)P(W)这条公式使用了贝叶斯公式，把语音识别分成了两个部分。一部分是声学模型，一部分是语言模型。直观地理解，就是估计一个词，使得公式右侧的">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/gmm-eg.jpeg">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/forward.jpeg">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/viterbi-max.jpeg">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/viterbi-pointer.jpeg">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/viterbi-bp.jpeg">
<meta property="og:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/backward.jpeg">
<meta property="og:updated_time" content="2018-05-10T09:27:19.782Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GMM-HMM模型（理论篇）">
<meta name="twitter:description" content="语音识别有一条最基础的公式： W^{*} = \mathop{argmax}_{W} P(W|X)P(W|X)=\frac{p(X|W)P(W)}{p(X)}\propto p(X|W)P(W)W^{*} = \mathop{argmax}_{W} p(X|W)P(W)这条公式使用了贝叶斯公式，把语音识别分成了两个部分。一部分是声学模型，一部分是语言模型。直观地理解，就是估计一个词，使得公式右侧的">
<meta name="twitter:image" content="https://pages.harryfyodor.xyz/2017/11/05/gmm-hmm-model/gmm-eg.jpeg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> GMM-HMM模型（理论篇） - harryfyodor </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">harryfyodor</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          GMM-HMM模型（理论篇）
        
      </h1>

      <time class="post-time">
          Nov 05 2017
      </time>
    </header>



    
            <div class="post-content">
            <p>语音识别有一条最基础的公式：</p>
<script type="math/tex; mode=display">W^{*} = \mathop{argmax}_{W} P(W|X)</script><script type="math/tex; mode=display">P(W|X)=\frac{p(X|W)P(W)}{p(X)}\propto p(X|W)P(W)</script><script type="math/tex; mode=display">W^{*} = \mathop{argmax}_{W} p(X|W)P(W)</script><p>这条公式使用了贝叶斯公式，把语音识别分成了两个部分。一部分是<em>声学模型</em>，一部分是<em>语言模型</em>。直观地理解，就是估计一个词，使得公式右侧的结果最大化。这个公式，可以粗略理解成一个模型。我们希望得到的结果是：在当前的语音X之下，我们输入一个词W，它能使得这个模型取得最大的值。而拆分来看，前者就是声学模型，后者就是语言模型。</p>
<p>这个语音数据X指的是MFCC特征，是一个vector，而不是语音信号本身或者语音频谱本身。所有的工作都是在提取了这个特征的基础上做的。我们希望能够通过一系列的语音数据的vector训练出一个模型。这个模型能够在我们给了它一个语音vector之后，判断出这段语音的内容。判断的过程被成为decode。</p>
<p>结合上面的内容，声学模型作用就是：找出符合的音。然而，语言当中存在着大量的同音字，同音的片段。找出符合的音还不够，我们还需要找到符合的字。而语言模型的工作就是这个。</p>
<p>本文会介绍声学模型的细节和原理。这个模型是GMM-HMM。虽然这是一个比较有历史的模型，效果比起现在的DNN-HMM等肯定是差了不少。但是，这不妨碍我们学习它。这一个模型的实现结合了机器学习相关的非常多的知识点，其实是非常有意思的。</p>
<p>我希望能够写得尽量浅显，但如果文章有所疏漏或者错误，恳请指正。</p>
<h3 id="1-直观了解两个算法"><a href="#1-直观了解两个算法" class="headerlink" title="1 直观了解两个算法"></a>1 直观了解两个算法</h3><p>在正式进入介绍GMM-HMM模型之前，先直观介绍两个常用的机器学习算法。在这里不会深入探讨细节，只关注最直观的原理和使用方法，仅让读者能有个概念的印象。想要深入了解的话，可以查看《统计学习方法》的相关章节或者查看一些其他的博客。</p>
<h4 id="1-1-EM算法"><a href="#1-1-EM算法" class="headerlink" title="1.1 EM算法"></a>1.1 EM算法</h4><p>EM算法在《数学之美》中被作者称为上帝算法，由此可见它的威力和魅力。</p>
<p>这个算法想要解决的问题是，当模型含有隐变量的时候，如何求得概率模型的极大似然估计。举个例子来说，我有三个罐子，罐子里有黑球和白球。每一个罐子里的黑白球都有各自的概率分布。我按照一个概率的规则，选一个罐子。然后把手伸到选好的罐子里面拿出一个球。重复上面的操作，我能够得到一个黑白球的一串序列。把这个序列称为输出序列O。</p>
<p>下面的问题是，我如何通过这一串序列，推测出每一个罐子里的概率分布的最大可能性，怎样推测出，我最有可能按照什么规则来选择罐子的。</p>
<p>EM算法就能回答这个问题。它把这个问题给分成了两个步骤。估计步骤和最大化步骤。</p>
<p>一开始，我们先初始化一些参数。这些参数包括两个部分：每一个罐子里面黑白球的概率分布，以及我选择罐子的规律（或者说概率，比较合适）。</p>
<p>然后，在当前的获得的序列，和当前估计的参数之下，我们要计算一个期望值。我当前估计的选择罐子的这套规律之下，对取到这一个序列O的期望（Q函数）（E-step）。</p>
<p>之后，我们再通过最大化这个我们得到的期望值。得到一组新的参数（M-step）。我们把新的参数放入上一步的构建当中，一直到Q函数或者估计参数收敛为止。</p>
<p>如果上面说的比较难以懂，可以这样理解：我们根据当前参数，构建最大似然估计一个下界。然后再最大化这个下界。这就是EM算法了。这样的操作过后，我们就得到了最终的估计，也就是说，最有可能的一个估计。</p>
<p>这样，我们就获取到了所有的参数，得到了整一个模型。</p>
<p>EM算法应用广泛，下面的K-means算法和GMM的算法都是他的应用。</p>
<h4 id="1-2-K-means算法"><a href="#1-2-K-means算法" class="headerlink" title="1.2 K-means算法"></a>1.2 K-means算法</h4><p>K-means很容易理解。我们可以通过这一个算法，把一个空间中的vectors分成若干聚类。具体的算法步骤很好理解，就在下面展示出来。</p>
<ol>
<li><p>随机初始化一些聚类的重心。</p>
</li>
<li><p>遍历每一个点，把点归属到距离它最近的那个重心的类别里。</p>
</li>
<li><p>遍历每一个重心，通过它类别里面的点重新求出均值，得到新的重心。</p>
</li>
<li><p>不停循环上面的的步骤2,3，直到收敛。</p>
</li>
</ol>
<p>以后如果有机会，会开一篇博客用代码详述。</p>
<h3 id="2-GMM"><a href="#2-GMM" class="headerlink" title="2 GMM"></a>2 GMM</h3><h4 id="2-1-什么是GMM"><a href="#2-1-什么是GMM" class="headerlink" title="2.1 什么是GMM"></a>2.1 什么是GMM</h4><p>高斯混合模型是混合模型的一种形式。其中的概率密度是一个高斯分布。它总体的概率分布就是把每一个高斯分布按照一定参数累加而成的。下面的公式就是GMM。在不同权重之下的高斯模型的累加。</p>
<script type="math/tex; mode=display">p(x)=\sum_{m=1}^{M}P(m)N(x;\mu _{m},\sigma _{m}^{2})</script><h4 id="2-2-如何训练GMM"><a href="#2-2-如何训练GMM" class="headerlink" title="2.2 如何训练GMM"></a>2.2 如何训练GMM</h4><p>什么是训练GMM呢？我们可以这样理解，给出一系列的点，希望能够有一个模型能够去拟合它们。而这明显地，是一个有隐性变量的概率分布（我们并不知道得到的点是从哪一个高斯分布来的）。因此我们可以用EM算法去训练出它的模型。</p>
<p>这一个模型有三个（组）重要的参数：混合参数，高斯的均值，高斯的方差。训练模型，就是得到这三个（组）参数的过程。这里的组数指的就是隐变量的个数。</p>
<p>我们先假设，我们知道我们的数据是哪一个高斯生成的。我们慢慢地数，可以得到这样的一系列参数。</p>
<p>但问题是，我们不知道一个数据点是来自哪一个高斯分布的。不知道分布，至少，要知道概率是多少。这里，我们可以用一个后验概率来表示。</p>
<script type="math/tex; mode=display">P(m|x_{t})</script><p>这一个概率被成为Component Occupation Probabilities。表示的含义是，当前数据点x属于高斯m的概率。用EM的说法就是，当前数据点属于某一个隐变量的概率是多少。</p>
<p>下面，我们可以用这一个概率把参数都表示出来了。</p>
<script type="math/tex; mode=display">\hat{\mu _{m}}=\frac{\sum_{t}P(m|x_{t})x_{t}}{\sum_{t}P(m|x_{t})}</script><script type="math/tex; mode=display">\hat{\sigma_{2}^{m}}=\frac{\sum_{t}P(m|x_{t})||x_{t}-\hat{\mu _{m}}||^{2}}{\sum_{t}P(m|x_{t})}</script><script type="math/tex; mode=display">\hat{P}(m)=\frac{1}{T}\sum_{t}P(m|x_{t})</script><p>整一个算法的流程如下：</p>
<ol>
<li><p>初始化参数</p>
</li>
<li><p>使用估计的参数计算概率（就是Component Occupation Probabilities）</p>
</li>
<li><p>通过刚刚估计的概率分布，进行参数的估计（就是上面的公式）</p>
</li>
<li><p>重复2,3，直到收敛</p>
</li>
</ol>
<p>下面的图就展示出了训练获得的GMM模型。</p>
<p><img src="gmm-eg.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<h3 id="3-HMM"><a href="#3-HMM" class="headerlink" title="3 HMM"></a>3 HMM</h3><p>马尔科夫模型考虑的问题是转移概率的问题，而隐性马尔科夫模型考虑的问题是，对于每一个状态，各自有一个隐性概率分布的情况下，相关的问题。</p>
<p>与上面提到的EM算法的例子相似的是，我都要通过一个隐性的规则，先去选择罐子，然后再到罐子里面拿球。差别是，我这一套隐性的规则，不再是单纯的通过一个规律来选择。每次选完一个罐子，我都需要根据一个矩阵来决定下一个我要用的罐子。这个矩阵叫做转移概率矩阵。</p>
<script type="math/tex; mode=display">\begin{bmatrix}
a_{11} & a_{12} & a_{13}\\ 
a_{21} & a_{22} & a_{23}\\ 
a_{31} & a_{32} & a_{33}
\end{bmatrix}</script><p>这里<script type="math/tex">a_{ij}</script>的含义就是，从状态i到j的转移概率。</p>
<p>我有三个罐子，A，B和C。我第一次把收根据pi的概率选择一个罐子，然后拿一个球（根据罐子里面球的分布b），然后根据转移概率矩阵A，再选择一个罐子。拿一个球。不停重复，获得一个观察序列O。每一个观察序列上的点都来自一个状态，即来自哪一个罐子。这个状态的序列标记为Q。</p>
<p>参数主要就是转移概率矩阵A，球在罐子里的分布b，选择的罐子的分布<script type="math/tex">\pi</script>。我们把它记为<script type="math/tex">\lambda</script> 。</p>
<p>下面，我们要解决三个问题。这三个问题是是整个GMM-HMM模型的核心。下面我们就来探索一下这三个问题。</p>
<h4 id="3-1-Likelihood"><a href="#3-1-Likelihood" class="headerlink" title="3.1 Likelihood"></a>3.1 Likelihood</h4><p>我们拿到了观察序列O，我们也知道了整个模型<script type="math/tex">\lambda</script>。想要求得在这个模型下，我得到O的概率是多少。</p>
<p>知道这个问题的解决方案的好处是：如果我有两个用来识别”Hello”的模型，我想知道哪一个模型更好，只要分别求得这两个<script type="math/tex">p(x|\lambda)</script>的概率，一对比就知道了。</p>
<p>从最直接的想法来说，可以把所有路线都走一遍。这种方法复杂度太高，不实用。我们可以选择使用一个更好的方法：前向算法。</p>
<p>定义：已知观察序列X，那么，在时间t的时候（此时的观察序列对应的点为<script type="math/tex">x_{t}</script>），状态为j的概率是：</p>
<script type="math/tex; mode=display">\alpha_{t}(j)</script><p>算法的具体流程如下：</p>
<ul>
<li>初始化</li>
</ul>
<script type="math/tex; mode=display">\alpha_{0}(s_{1})=1</script><script type="math/tex; mode=display">\alpha_{0}(j)=0 \ j\neq s_{1}</script><ul>
<li>循环<br>这是最核心的一步。通过递归的方法，可以求得，对一个时间t，状态j的概率是前面一个时间t-1的全部可能性转移到当前状态的概率的累加。简单理解是：前一个步骤的每一个时间点的每一个状态都出色完成了自己的任务（生成xt-1）,要把这些可行的路线的可能性都综合起来。</li>
</ul>
<script type="math/tex; mode=display">\alpha_{t} = \sum_{i=1}^{N}\alpha_{t-1}a_{ij}b_{j}(x_{t})</script><script type="math/tex; mode=display">1\leq j\leq N,1 \leq t \leq T</script><p>通过下面的图可以更加清晰地了解。</p>
<p><img src="forward.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<ul>
<li>终止</li>
</ul>
<script type="math/tex; mode=display">p(X|\lambda )=\sum_{i=1}^{N}\alpha_{T}(i)</script><h4 id="3-2-Decoding"><a href="#3-2-Decoding" class="headerlink" title="3.2 Decoding"></a>3.2 Decoding</h4><p>现在知道了观察序列O和模型 <script type="math/tex">\lambda</script>我想猜测出最有可能的状态序列Q。这一个问题的用处在于：我们可以根据当前的一串数据，推测数据的状态来源。我有一条语音信号，也选好模型了，我想通过模型把语音信号解码出来。</p>
<p>这一个问题和上一个问题的算法很相似，因为事实上他们面对的问题也有很高的相似性。差别只在于，我在解码的时候，我只会走最好的一条路，而求似然性，则是全局的。</p>
<p>解码这一个步骤最常用的算法是经典的<em>维特比算法</em>。算法的思想如下所述：在一个时间t，状态是j，我们想知道走到这一步最有可能的路线，就要看到达上一个时间点的每个状态的可能性。到达当前点最有可能的路线，就是到达前一个状态最有可能的路线乘上前一个状态过来的可能性最大的那条路线。</p>
<p>打个比方，旅行者想去G城，要途径A，B，C城。他想要快点到达G成，要考虑两个问题，我到达A，B，C要多久，A，B，C三个地方出发到G城要多久。而我想知道到达A城最快要长时间，就要看A城前面的情况。这里就发生了递归。通过递归，我们也能找到一条最好的解码路径。</p>
<p>这么说或许有点复杂，结合公式和图就能很好地理解了。</p>
<ul>
<li>初始化</li>
</ul>
<script type="math/tex; mode=display">V_{0}(i)=1</script><script type="math/tex; mode=display">V_{0}(j)=0 \ if j \neq 0</script><script type="math/tex; mode=display">bt_{0}(j)=0</script><ul>
<li>循环</li>
</ul>
<script type="math/tex; mode=display">V_{t}(j)=\max_{i=1}^{N}V_{t-1}(i)a_{ij}b_{j}(x_{t})</script><p><img src="viterbi-max.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<script type="math/tex; mode=display">bt_{0}(j)=\mathop{argmax}_{i=1}^{N}V_{t-1}(i)a_{ij}b_{j}(x_{t})</script><p><img src="viterbi-pointer.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<ul>
<li>终止</li>
</ul>
<script type="math/tex; mode=display">P^{*}=V_{T}(s_{E})=\max_{i=1}^{N}V_{T}(i)</script><script type="math/tex; mode=display">s_{T}^{*}=bt_{T}(q_{E})=\mathop{argmax}_{i=1}^{N}V_{T}(i)</script><p><img src="viterbi-bp.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<p>为了最后得到那一条路线，我们在算法进行的过程中可以顺便把前一个的状态记录下来。这里就用来一个指针，可以在最后回溯。</p>
<h4 id="3-3-Training"><a href="#3-3-Training" class="headerlink" title="3.3 Training"></a>3.3 Training</h4><p>最后一个问题是，知道了观察序列O，或者说大量的观察序列O，我们要怎样获取这一个模型。</p>
<p>这个问题是最难的一个问题。把这个问题具体化，事实上就是通过训练序列O，找到使得相同的语音数据输入的时候，这个模型能够给出最大的似然估计。我们需要的隐变量既包括每一个状态的概率分布参数，又包括整体的状态转移矩阵参数。因此这又是一个EM算法的问题。</p>
<p>这里，我们做一个假设，把每一个状态的概率分布近似城混合高斯模型。在这个假设下，我们的整一个算法，就可以非常直观地看成是上面GMM算法的一个延神。GMM的EM算法，隐变量只有”属于哪一个高斯“这一点。而这里的EM算法，包括了下面三个隐变量：我要选择哪一个状态，选好状态（都假设为GMM了）之后的结果属于哪一个高斯分布，转移去的下一个状态是什么。</p>
<p>类似GMM算法，我们也需要知道，某个时间点是某一个状态的概率，以及，t时刻是某个状态到t+1时刻是某个状态的概率。这两个概率的表示都是我们EM算法中E-step要使用的。</p>
<h5 id="3-3-1-后向算法"><a href="#3-3-1-后向算法" class="headerlink" title="3.3.1 后向算法"></a>3.3.1 后向算法</h5><p>为了得到这两个概率，我们要引入后向算法。</p>
<p>后向算法与前向算法类似。不过差别在于，前向算法是，假设前面都符合要求，当前时刻属于某个特定状态，也符合要求，的概率是多少。而后向算法则是，假设后面的时刻都符合要求，当前时刻也符合要求，的概率是多少。</p>
<p>（这里的符合要求指的是符合输出序列的值。）</p>
<p>算法的过程如下所示：</p>
<ul>
<li>初始化<br>这里的初始化为1，是因为当到达最后的时候，我假设当前符合要求，后面已经没有其他的状态了，因此必然符合要求。 </li>
</ul>
<script type="math/tex; mode=display">\beta_{i}(s_{1})=1</script><ul>
<li>循环<br>这一步与前向算法类似，通过递归，从后往前算。</li>
</ul>
<script type="math/tex; mode=display">\beta_{t} = \sum_{i=1}^{N}a_{ij}b_{j}(x_{t+1})\beta_{t+1}(j)</script><script type="math/tex; mode=display">for\ t = T -1,...,1</script><p><img src="backward.jpeg" style="margin-left:50%;transform: translateX(-50%);"></p>
<ul>
<li>最后（从正常顺序来说，是最前。）</li>
</ul>
<script type="math/tex; mode=display">p(X|\lambda )=\sum_{i=1}^{N}a_{1j}b_{j}(x_{1})\beta_{1}(j)</script><h5 id="3-3-2-BW算法"><a href="#3-3-2-BW算法" class="headerlink" title="3.3.2 BW算法"></a>3.3.2 BW算法</h5><p>后向算法的作用，是它能够和前向算法配合，表示出上面所讲的两个概率。</p>
<p>对于一个序列来说，在t时刻属于状态j的概率（我们称之为state occupation probability，类似GMM的情况），这里可以表示为：</p>
<script type="math/tex; mode=display">\gamma _{t}(j)=P(S(t)=j|X,\lambda)=\alpha_{t}(j)\beta_{t}(j)</script><p>对于一个序列来说，t时刻由i状态转移到j状态的概率，我们可以表示为：</p>
<script type="math/tex; mode=display">\xi_{t}(i, j) = P(S(t)=i,S(t+1)=j|X,\lambda) = \alpha_{t}(i)a_{ij}b_{j}(x_{t+1})\beta_{t+1}(j)</script><p>而此时，考虑一个相对简单的情况，即状态的分布为单高斯的情况。需要估计的参数就可以根据上面的两个概率表示出来。</p>
<script type="math/tex; mode=display">\hat\mu_{j} = \frac{\sum_{t=1}^{T}\gamma_{t}(j)x_{t} }{\sum_{t=1}^{T}\gamma_{t}(j)}</script><script type="math/tex; mode=display">\hat\sum_{j}=\frac{\sum_{t=1}^{T}\gamma_{t}(j)(x_{t}-\hat\mu_{j})(x-\hat\mu_{j})^{T}}{\sum_{t=1}^{T}\gamma_{t}(j)}</script><script type="math/tex; mode=display">\hat a_{ij}=\frac{\sum_{t=1}^{T}\xi _{t}(i,j)}{\sum_{k=1}^{N}\sum_{t=1}^{T}\xi_{t}(i, k)}</script><p>EM算法的两个步骤，到此就可以表示出来了。</p>
<ul>
<li>E-step<ol>
<li>前向算法计算<script type="math/tex">\alpha_{t}(j)</script>和后向算法计算<script type="math/tex">\beta_{t}(j)</script></li>
<li>计算上面说的两个概率<script type="math/tex">\gamma_{t}(j)</script>, <script type="math/tex">\xi_{t}(i, j)</script></li>
</ol>
</li>
<li>M-step<ol>
<li>通过E-step估计的概率进行参数的迭代。这里的参数包括<script type="math/tex">\hat \mu_{j}</script>, <script type="math/tex">\sum_{j}</script>, <script type="math/tex">\hat a_{ij}</script></li>
</ol>
</li>
</ul>
<p>重复上面的EM步骤，直到收敛，模型就训练完毕了。</p>
<p>如果从刚刚的假设中跳转到真实的情况里，即，使用GMM而不是单高斯的情况时，有一些参数需要进行调整。</p>
<p>假设，对于每一个循环的均值来说，需要考虑向量落在哪一个高斯分量中，因此需要做如下的修改。</p>
<script type="math/tex; mode=display">\hat \mu_{jm} = \frac{\sum_{t=1}^{T}\gamma_{t}(j, m)x_{t}}{\sum_{t=1}^{T}\gamma_{t}(j, m)}</script><p>而GMM的参数也需要不停地迭代，来重新调整模型。下面就是GMM参数调整的公式。</p>
<script type="math/tex; mode=display">\hat c_{jm} = \frac{\sum_{t=1}^{T}\gamma_{t}(j, m)}{\sum_{n=1}^{M}\sum_{t=1}^{T}\gamma_{t}(j, n)}</script><h3 id="4-最后"><a href="#4-最后" class="headerlink" title="4 最后"></a>4 最后</h3><p>到这里，GMM-HMM模型涉及的所有理论都已经讲述完毕。之后会写一篇文章来详细说说，怎样把这些算法用起来。</p>
<h3 id="5-学习资料分享"><a href="#5-学习资料分享" class="headerlink" title="5 学习资料分享"></a>5 学习资料分享</h3><ul>
<li>爱丁堡大学语音识别课课件 <a href="https://www.inf.ed.ac.uk/teaching/courses/asr/" target="_blank" rel="noopener">https://www.inf.ed.ac.uk/teaching/courses/asr/</a></li>
<li>雷锋网的一篇科普文章 <a href="https://www.leiphone.com/news/201609/ujyg57ZsXcl9Dipg.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201609/ujyg57ZsXcl9Dipg.html</a></li>
<li>一个HMM的相关教程 <a href="http://www.kanungo.com/software/hmmtut.pdf" target="_blank" rel="noopener">http://www.kanungo.com/software/hmmtut.pdf</a></li>
<li>经典 The Application of Hidden Markov Models in Speech Recognition</li>
</ul>
<p>本文所有图片来源于爱丁堡大学语音识别课件。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/语音识别/">语音识别</a>
		  
			<a href="/tags/机器学习/">机器学习</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/11/13/decoder-intro/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">语音识别解码器简单简介</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/10/17/make-mfcc/">
        <span class="next-text nav-default">提取MFCC特征</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <div style="text-align:center;">
        <button class="btn" id="load-disqus" onclick="disqus.load();">加载 Disqus 评论</button>
    </div>
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2018
    <span class="footer-author">harryfyodor.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/javascript">
  $(document).ready(function(){
    $("code").map(function(){
      match = /^\$(.*)\$$/.exec($(this).html());
      if (match){
        //$(this).after("<span class=mathjax_inline>" + match + "</span>");
        //$(this).hide();
        $(this).replaceWith("<span class=hpl_mathjax_inline>" + $(this).html() + "</span>");
        MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]);
      }
    });
  });
  </script>
    

<script type="text/javascript">
  var disqus_shortname = 'harry-blog';
  var disqus_identifier = '2017/11/05/gmm-hmm-model/';

  var disqus_title = "GMM-HMM模型（理论篇）";


  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
